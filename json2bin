#!/usr/bin/env node

var fs   = require("fs"),
    path = require("path"),
    COARSE_WIDTH    = 48,
    COARSE_HEIGHT   = 24,
    FINE_WIDTH      = 2,
    FINE_HEIGHT     = 2,
    MAX_DEPTH       = 9,
    MAX_DISTANCE_SQ = 0.16,
    TIMEZONE_INTERNATIONAL_LIST = [
      "Etc/GMT+12", "Etc/GMT+11", "Etc/GMT+10", "Etc/GMT+9",  "Etc/GMT+8",
      "Etc/GMT+7",  "Etc/GMT+6",  "Etc/GMT+5",  "Etc/GMT+4",  "Etc/GMT+3",
      "Etc/GMT+2",  "Etc/GMT+1",  "Etc/GMT",    "Etc/GMT-1",  "Etc/GMT-2",
      "Etc/GMT-3",  "Etc/GMT-4",  "Etc/GMT-5",  "Etc/GMT-6",  "Etc/GMT-7",
      "Etc/GMT-8",  "Etc/GMT-9",  "Etc/GMT-10", "Etc/GMT-11", "Etc/GMT-12"
    ];

function bound(poly) {
  var bound = [
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY
      ],
      i;

  for(i = poly.length; i--; ) {
    if(poly[i][0] < bound[0]) bound[0] = poly[i][0];
    if(poly[i][0] > bound[2]) bound[2] = poly[i][0];
    if(poly[i][1] < bound[1]) bound[1] = poly[i][1];
    if(poly[i][1] > bound[3]) bound[3] = poly[i][1];
  }

  return bound;
}

function area(poly) {
  var area = 0.0,
      a = poly[0],
      i, b;

  for(i = poly.length; i--; ) {
    b = a;
    a = poly[i];
    area += a[0] * b[1] - a[1] * b[0];
  }

  return Math.abs(area * 0.5);
}

function contains(polygon, lat, lon) {
  var a = polygon[0],
      t = false,
      i, b;

  for(i = polygon.length; i--; ) {
    b = a;
    a = polygon[i];

    if(((a[1] <= lat && lat < b[1]) || (b[1] <= lat && lat < a[1])) && ((lon - a[0]) < ((b[0] - a[0]) * (lat - a[1]) / (b[1] - a[1]))))
      t = !t;
  }

  return t;
}

/* This actually returns the distance squared. :p */
function line(lat, lon, a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      u;

  if(x === 0.0 && y === 0.0) {
    x = a[0];
    y = a[1];
  }

  else {
    u = ((lon - a[0]) * x + (lat - a[1]) * y) / (x * x + y * y);

    if(u <= 0.0) {
      x = a[0];
      y = a[1];
    }

    else if(u >= 1.0) {
      x = b[0];
      y = b[1];
    }

    else {
      x = a[0] + u * x;
      y = a[1] + u * y;
    }
  }

  x -= lon;
  y -= lat;
  return x * x + y * y;
}

function distance(lat, lon, polygon) {
  var distance = Number.POSITIVE_INFINITY,
      a = polygon[0],
      b, i, t;

  for(i = polygon.length; i--; ) {
    b = a;
    a = polygon[i];
    t = line(lat, lon, a, b);

    if(t < distance)
      distance = t;
  }

  return distance;
}

function Polygon(feature) {
  this.tzid = feature.properties.TZID;
  this.data = feature.geometry.coordinates;
  this.__boundingBox();
  this.__area();
}

Polygon.prototype = {
  __boundingBox: function() {
    this.box = bound(this.data[0]);
  },
  __area: function() {
    var i;

    this.area = area(this.data[0]);
    for(i = this.data.length; --i; )
      this.area -= area(this.data[i]);
  },
  overlap: function(that_box) {
    return this.box[0] <= that_box[2] && this.box[1] <= that_box[3] &&
           this.box[2] >= that_box[0] && this.box[3] >= that_box[1];
  },
  distance: function(lat, lon) {
    var i;

    /* Outside polygon: return distance to the edge. */
    if(!contains(this.data[0], lat, lon))
      return distance(lat, lon, this.data[0]);

    /* Inside polygon hole: return distance to hole's edge. */
    for(i = this.data.length; --i; )
      if(contains(this.data[i], lat, lon))
        return distance(lat, lon, this.data[i]);

    /* Inside polygon but outside all holes. */
    return 0.0;    
  }
};

function readGeoJSON(pathname, callback) {
  var i, data;

  data = JSON.parse(fs.readFileSync(pathname, "ascii")).features;

  for(i = data.length; i--; ) {
    if(!data[i].properties ||
       !data[i].properties.TZID ||
       data[i].properties.TZID === "uninhabited") {
      data.splice(i, 1);
    }

    else {
      data[i] = new Polygon(data[i]);
    }
  }

  data.sort((a, b) => a.area - b.area);

  return data;
}

function tzindex(polygons) {
  var hash = {},
      list = [],
      i;

  for(i = TIMEZONE_INTERNATIONAL_LIST.length; i--; )
    hash[TIMEZONE_INTERNATIONAL_LIST[i]] = -1;

  for(i = polygons.length; i--; )
    hash[polygons[i].tzid] = -1;

  for(i in hash)
    if(hash.hasOwnProperty(i))
      list.push(i);

  list.sort();

  for(i = list.length; i--; )
    hash[list[i]] = i;

  return {list: list, hash: hash};
}

function write(root, nzones) {
  var queue = [],
      nodes = [],
      len   = 0,
      off   = 0,
      max   = 0x10000 - nzones,
      node, i, data, t, j;

  for(queue.push(root); node = queue.shift(); ) {
    node.id = nodes.length;
    nodes.push(node);
    len += (node.width * node.height) << 1;

    for(i = 0; i < node.data.length; i++)
      if(typeof node.data[i] !== "number")
        queue.push(node.data[i]);
  }

  //fs.writeFileSync("moop.json", JSON.stringify(root));
  console.warn("TILE_COUNT = %d, BYTE_LENGTH = %d", nodes.length, len);
  data = new Buffer(len);
  
  for(i = 0; i < nodes.length; i++) {
    node = nodes[i];

    for(j = node.data.length; j--; ) {
      if(typeof node.data[j] === "number")
        t = node.data[j];

      else {
        /* We can subtract 1 since indices are unique; thus we never need to
         * worry about t being zero before the subtraction. */
        t = (node.data[j].id - node.id) - 1;

        if(t >= max)
          throw new Error("too many tiles, sorry.");
      }

      data.writeUInt16BE(t, off + (j << 1));
    }

    off += (node.width * node.height) << 1;
  }

  fs.writeFileSync("tz.bin", data);
}

var polygons = readGeoJSON(path.join(__dirname, "tz_world.json"));

/* HACK: There is no such thing as America/Monterey! Change it to the correct
 * IANA timezone. */
var i;
for(i = polygons.length; i--; ) {
  if(polygons[i].tzid === "America/Monterey") {
    polygons[i].tzid = "America/Monterrey";
  }
}

var zones = tzindex(polygons);

function tile(polygons, min_lat, min_lon, max_lat, max_lon, width, height, depth) {
  var box = [
        min_lon - MAX_DISTANCE_SQ,
        min_lat - MAX_DISTANCE_SQ,
        max_lon + MAX_DISTANCE_SQ,
        max_lat + MAX_DISTANCE_SQ
      ],
      lat = (min_lat + max_lat) * 0.5,
      lon = (min_lon + max_lon) * 0.5,
      list = [],
      i, data, x, y, best, dist, t, flat, dlat, dlon;

  for(i = polygons.length; i--; )
    if(polygons[i].overlap(box))
      list.push(polygons[i]);

  /* No polygons cover the area? Well then, just exit early. */
  if(list.length === 0)
    return (0x10000 - zones.list.length) + zones.hash[TIMEZONE_INTERNATIONAL_LIST[Math.round((180.0 + lon) / 15.0)]];

  /* Only one does? Then use it. (This isn't actually accurate, but our
   * compression is actually lossy. Furthermore, this just means that some
   * places will be considered land instead of ocean, which is actually
   * helpful for our use-case.) */
  if(list.length === 1)
    return (0x10000 - zones.list.length) + zones.hash[list[0].tzid];

  /* If we don't want to recurse any more, just return a single pixel. */
  if(depth === MAX_DEPTH) {
    best = null;
    dist = MAX_DISTANCE_SQ;
    for(i = list.length; i--; ) {
      box[0] = lon - dist;
      box[1] = lat - dist;
      box[2] = lon + dist;
      box[3] = lat + dist;
      if(!list[i].overlap(box))
        continue;

      t = list[i].distance(lat, lon);
      if(t >= dist)
        continue;

      best = list[i];
      dist = t;
    }

    return (0x10000 - zones.list.length) + zones.hash[best ? best.tzid : TIMEZONE_INTERNATIONAL_LIST[Math.round((180.0 + lon) / 15.0)]];
  }

  /* Look up the entire tile. */
  data = new Array(width * height);
  flat = true;
  dlat = (max_lat - min_lat) / height;
  dlon = (max_lon - min_lon) / width;
  for(y = height; y--; ) {
    for(x = width; x--; ) {
      t = tile(
        list,
        min_lat + (height - (y + 1)) * dlat,
        min_lon + (x + 0) * dlon,
        min_lat + (height - (y + 0)) * dlat,
        min_lon + (x + 1) * dlon,
        FINE_WIDTH,
        FINE_HEIGHT,
        depth + 1
      );

      data[y * width + x] = t;

      if(typeof t !== "number")
        flat = false;
    }
  }

  /* Check to see if there's only one non-ocean color. If so, use it. If not,
   * if the only color is ocean, use that. Otherwise, I guess we have to
   * return the whole thing, oh well. */
  if(flat) {
    t = -1;

    for(i = data.length; i--; ) {
      if(data[i] === t)
        continue;

      if(zones.list[data[i] - (0x10000 - zones.list.length)].slice(0, 3) === "Etc")
        continue;

      if(t !== -1)
        break;

      t = data[i];
    }

    if(i === -1) {
      if(t === -1)
        t = (0x10000 - zones.list.length) + zones.hash[TIMEZONE_INTERNATIONAL_LIST[Math.round((180.0 + lon) / 15.0)]];

      return t;
    }
  }

  return {id: -1, width: width, height: height, data: data};
}

fs.writeFileSync("tz.json", JSON.stringify(zones.list));
write(tile(polygons, -90.0, -180.0, +90.0, +180.0, COARSE_WIDTH, COARSE_HEIGHT, 0), zones.list.length);
